@startuml
' TODO

' --------

' ==== < CONFIGURATION > ====

hide empty members
hide <<function>> circle

' ==== END of < CONFIGURATION > ====

package "Factory Package" {

	class NodeCollection<Node> << (T,olive) >> {
		- nodes: std::list<Node>
		+ getNodes() : std::list<Node>
		+ cbegin() : std::list<Node>::const_iterator
		+ cendt() : std::list<Node>::const_iterator
		+ begin() :std::list<Node>::iterator
		+ begin() : std::list<Node>::const_iterator
		+ end() : std::list<Node>::iterator
		+ end() : std::list<Node>::const_iterator
	}

	Ramps ..|> NodeCollection : <<bind>> <Node->Ramp>
	Workers ..|> NodeCollection : <<bind>> <Node->Worker>
	Storehouses ..|> NodeCollection : <<bind>> <Node->Storehouse>

	class Factory {
		-_ramps : NodeCollection<Ramp>
		-_workers: NodeCollection<Worker>
		-_storehouses: NodeCollection<Storehouse>
		+Factory(ramps : NodeCollection<Ramp>, workers: 				NodeCollection<Worker>, storehouses: 				NodeCollection<Storehouse>)
		+add(nodeId : ElementID) : void
		+isCompatible() : bool {query}
		+findById(nodeId: ElementID) : iterator
		+findById(nodeId: ElementID) : const_iterator
		+removeById(nodeID : ElementID) : void
	}
	Factory *-- Ramps
	Factory *-- Workers
	Factory *-- Storehouses

}
' == END of package "Factory"

package "Report Generation" {

	interface IReportNotifier <<interface>> {
	}

	class SpecificTurnsReportNotifier {
	}
	SpecificTurnsReportNotifier .. IReportNotifier

	class IntervalReportNotifier {
	}
	IntervalReportNotifier .. IReportNotifier 

	class Reporting <<function>> {
		generate_structure_report(?)
		generate_simulation_turn_report(?)
	}

}
' == END of package "Report Generation"

class Simulation <<function>> {
	simulate(?)
}
Simulation ..> Factory : uses
Reporting .. Simulation
IReportNotifier .. Simulation


package "Storage" {

	interface IPackageStockpile <<interface>> {
	} 

	interface IPackageQueue <<interface>> {
	} 
	IPackageQueue .. IPackageStockpile

	enum QueueType <<enumeration>> {
	}
	QueueType .. IPackageQueue

	class PackageQueue {
	}
	PackageQueue .. IPackageQueue

	class Package {
	- {static}maxID : ElementID
	- product_id : ElementID
	+ Package()
	+ getProductId() : ElementID
	}

}
' == END of package "Storage"


package "Nodes" {

	interface IPackageReceiver <<interface>> {
	}

	enum ReceiverType <<enumeration>> {
	}
	IPackageReceiver .. ReceiverType


	class ReceiverPreferences {
	}


	class PackageSender {
	}

	PackageSender .. ReceiverPreferences

	class Ramp {
 	+ Ramp()
	+ generatePackage() : void
	}

	Ramp .. PackageSender


	class Worker {
	+ Worker()
	+ processPackage() : void
	+ receiveProduct() : void
	- _package_queue : std::unique_ptr <Package>
	}

	Worker .. PackageSender
	Worker .. IPackageReceiver
	IPackageQueue .. Worker

	class Storehouse {
	+ Storehouse()
	+ receiveProduct() : void
	- _package_queue : std::unique_ptr
	}

	Storehouse .. IPackageReceiver
	IPackageStockpile .. Storehouse

	Ramp -[hidden]> Worker
	Worker -[hidden]> Storehouse

	' == POSITIONING ==
	PackageSender -[hidden]> IPackageReceiver
	' == END of POSITIONING ==
}
' == END of package "Nodes"


' .. HELPERS ----

' .. DATA TYPES --
together {
	class Time << (T,orchid) primitive>>
	class TimeOffset << (T,orchid) primitive>>
	class ElementID << (T,orchid) primitive>>
	class ProbabilityGenerator << (T,orchid) primitive>>

	Time -[hidden]> TimeOffset
	TimeOffset -[hidden]> ElementID
	ElementID -[hidden]> ProbabilityGenerator
}

class IO <<function>> {
	load_factory_structure(?)
	save_factory_structure(?)
}

' == END of together


' ==== < POSITIONING > ====

IO <-[hidden]- IntervalReportNotifier
Time <-[hidden]- Package

ReceiverPreferences <-[hidden]- IPackageStockpile

IPackageStockpile -[hidden]-> Storehouse

"Factory Package" +- "Nodes"

IReportNotifier -[hidden]> Reporting

' ==== END of < POSITIONING > ====
@enduml
